# Think in Java

## 第一章 对象导论

#### 1.oop概念  
	(01) 面向对象程序设计 Object-oriented Programming OOP  
	(02) 抽象过程 抽象是什么？ 
		众多对象的共同点 抽象过程是就相当于求公约数的过程 香蕉 苹果 梨都被识别为水果 这个识别的过程就是抽象的过程  
	(03).访问控制存在原因(访问控制就是为了避免程序被改动脆弱的部分，为了减少程序bug)  
	(04) 代码复用(设计模式)
	(05) 组合：一个新类里面包含另外一个类的对象？ 聚合：组合动态发生的情况 （没理解 ）  
		[uml类图与类关系以及对组合聚合的解释](http://www.uml.org.cn/oobject/201104212.asp)  
	(06) 继承 导出类具有基类的所有成员和方法，包括私有的。  
		替代原则:重载基类的所有方法，不添加新的方法，基类与导出类类型完全相同。  
	(07) 多态 向上转型  
	(08) 单根继承 都继承object类
	(09) 容器(集合) 标准模板类库(STL Standard Template Library) java中包含list/map/Set等很多构件  
	(10) 参数化类型机制(泛型) 避免向上转型之后的向下转型的异常  
		ArrayList<shape> shapes = new ArrayList<Shape>();  
	(11) 垃圾回收机制  
	(12) 异常处理  
	(13) 并发机制  
	(14) java web(c/s)  
		html HyperText Markup Language 超文本标记语言  
		cgi 通用网关接口  
## 第二章 一切都是对象  

#### 2.1 引用  

	(1) String s 这是一个引用，但不是对象，对象需要初始化  
	(2) 对象存储位置 寄存器、堆栈、堆、常量存储、非RAM存储(存储在程序之外的，应该指的是PI之类的定义吧)  
	(3) 基本类型 高精度数字 BigInteger、BigDecimal并没有对应的基本类型(详细信息请见JDK 啊哈哈哈哈哈哈  [手动笑哭])  
	(4) java 数组定义 3种方式 本项目中summary文件夹中summary文件  
	(5) 永远不需要销毁对象 垃圾回收机制 消除内存泄漏问题  
	(6) 创建类  
	(7) 注释 嵌入式文档  
		如何生成javadoc呢？ 很简单，在eclipse中点击导航栏中的 project->Generate javadoc
		然后勾选需要生成文档的包以及生成文档的位置就OK啦！  
	(8) 编码规范：驼峰  

## 第三章 操作符  

#### 3 操作符  

	(1) equals() == 区别
		总之：“==”比较的是值【变量(栈)内存中存放的对象的(堆)内存地址】 equal用于比较两个对象的值是否相同【不是比地址】  
		【特别注意】Object类中的equals方法和“==”是一样的，没有区别，  
		而String类，Integer类等等一些类，是重写了equals方法，才使得equals和“==不同”，  
		所以，当自己创建类时，自动继承了Object的equals方法，要想实现不同的等于比较，必须重写equals方法。  

		"=="比"equal"运行速度快,因为"=="只是比较引用.  

	(2)关于printf格式化输出的一些简介：
		%c 单个字符  
		%d 十进制整数  
		%f 十进制浮点数  
		%o 八进制数  
		%s 字符串  
		%u 无符号十进制数  
		%x 十六进制数  
		%% 输出百分号%  
		printf的格式控制的完整格式：  
		% - 0 m.n l或h 格式字符  
		下面 对组成格式说明的各项加以说明：  
		①%：表示格式说明的起始符号，不可缺少。  
		②-：有-表示左对齐输出，如省略表示右对齐输出。  
		③0： 有0表示指定空位填0,如省略表示指定空位不填。  
		④m.n：m指域宽，即对应的输出项在输出设备上所占的字符数。N指精度。用于说明输出的实型数的小数位数。为指定n时，隐含的精度为n=6位。  
		⑤l或h:l对整型指long型，对实型指double型。h用于将整型的格式字符修正为 short型。  
	(3) return/break/continue/goto(保留字)/switch() {case:return;}  

## 第四章 控制执行流程  

	吸血鬼数字 算法  

## 第五章 初始化与清理

	构造器/重载  
		当自定义了一个构造器，编译器不会再创建默认构造器  
		自定义的构造函数中使用this不可以调用其他两个及以上构造器，并且只能在构造器中调用构造器  
		this应用：  
		应用一：引用成员变量  
		应用二：调用类的构造方法  
		应用三：返回对象的值  

	垃圾回收 finalize()  
	[留着以后研究 现在有点看不懂](http://www.tuicool.com/articles/FnumEb)  
	[这个也是](http://www.artima.com/insidejvm/ed2/gcP.html)  
	[文档](http://www.oracle.com/technetwork/java/gc-tuning-5-138395.html)  
	[关联](http://blog.csdn.net/pi9nc/article/details/12374049)  
	[关联](https://my.oschina.net/u/2297250/blog/383407)  
		java垃圾回收：  
			1、对象可能不被垃圾回收  
			2、垃圾回收并不等于析构，就是不等于删除对象后释放内存  
			3、垃圾回收只与内存有关  
		这个看的不是很明白 不知道什么条件才能被回收 不知道之后还有没有这部分内容 可能理解内存分配会能明白一点吧  暂时先记着  
		垃圾回收机制：引用计数/自适应(停止-复制/标记-清扫)
