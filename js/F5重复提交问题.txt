总体思路就是拦截F5按键，重新发个一览的检索请求，并传递页号
以下仅供参考

1.在自己的一览ctp里加上以下js代码
  // F5
  document.onkeydown = function(event) {
    var e = event || window.event || arguments.callee.caller.arguments[0];
    if (e && e.keyCode == 116) {
      if (e.preventDefault) {
        e.preventDefault();
      } else {
        e.keyCode = 0;
        e.returnValue = false;
      }
      window.location.href = $("#reloadUrl").val() + "?page=" + $("span.current").text();
    }
  }

2.在自己一览ctp里，加上想要按F5后的请求路径隐藏域
<input id="reloadUrl" type="hidden" value="<?php echo $this->html->url('/Branches/branchesList');?>" />

3.修改自己的一览检索方法
    public function branchesList() { // 根据自己的代码，参照备注修改
        $page = isset($_GET['page']) ? $_GET['page'] : 1; // 判断前台是否传递了page参数，我的画面初期化不传，所以传参page的就是我按F5发的请求
        $listCount = $this->paginate['limit'] * ($page - 1); // 少一页的件数
        $dbCount = $this->Branch->find('count'); // DB中实际的件数
        $this->paginate['page'] = $listCount == $dbCount ? $page - 1 : $page; // 少一页的件数和DB件数相同，说明之前最后一页没数据，页号-1，否则页号不变
        $this->Paginator->settings = $this->paginate; // 翻页设定
        $this->set('branches', $this->Paginator->paginate('Branch')); //翻页检索
    }